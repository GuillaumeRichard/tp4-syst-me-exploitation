#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from messages import Messages


def input_command():
    return input(Messages.ENTER_COMMAND)


def print_answer(answer):
    print(answer)


class Prompt:

    def __init__(self, client):
        self.client = client
        self.input_command = input_command
        self.print_answer = print_answer
        self.quit_has_been_called = False

    def start(self):
        self.print_welcome_message()
        self.listen_for_input()

    def print_welcome_message(self):
        self.print_answer(Messages.WELCOME_MESSAGE)

    def listen_for_input(self):
        while True:
            client_input = self.input_command()
            self.interpret_input(client_input)

            if self.quit_has_been_called:
                break

    def interpret_input(self, client_input):
        if client_input == "connecter?":
            self.greeting()
        elif client_input == "nomServeur?":
            self.get_server_name()
        elif "listeDossier?" in client_input:
            self.get_folder_list(client_input)
        elif "dossier?" in client_input:
            self.verify_folder_exists(client_input)
        elif "creerDossier?" in client_input:
            self.create_folder(client_input)
        elif "televerser?" in client_input:
            self.upload_file(client_input)
        elif "telecharger?" in client_input:
            self.download_file(client_input)
        elif "supprimerDossier?" in client_input:
            self.delete_folder(client_input)
        elif "supprimerFichier?" in client_input:
            self.delete_file(client_input)
        elif "fichier?" in client_input:
            self.verify_file_exists(client_input)
        elif "identiqueFichier?" in client_input or "fichierIdentique?" in client_input:
            self.verify_file_is_identical(client_input)
        elif "recentFichier?" in client_input or "fichierRecent?" in client_input:
            self.verify_file_is_more_recent(client_input)
        elif "miseAjour" in client_input:
            self.update(client_input)
        elif client_input == "quitter":
            self.quit()
        else:
            self.print_answer(Messages.BAD_COMMAND)

    def greeting(self):
        server_answer = self.client.greeting()

        if "bonjourClient" in server_answer:
            self.print_answer(Messages.YES)
        else:
            self.print_answer(Messages.NO)

    def get_server_name(self):
        server_name = self.client.get_server_name()

        self.print_answer(server_name)

    def get_folder_list(self, client_input):
        folder_name = self.get_command_argument(client_input)
        if folder_name:
            server_answer = self.client.get_folder_list(folder_name)
            print(server_answer)
            if "erreurDossierInexistant" in server_answer:
                self.print_answer(Messages.FOLDER_NOT_FOUND)
            elif "erreurDossierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FOLDER)
            else:
                for folder in server_answer:
                    self.print_answer(folder)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def verify_folder_exists(self, client_input):
        folder_name = self.get_command_argument(client_input)
        if folder_name:
            folder_exists = self.client.verify_folder_exists(folder_name)

            # si la réponse du serveur ne donne aucune erreur
            if folder_exists:
                self.print_answer(Messages.YES)
            else:
                self.print_answer(Messages.NO)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def create_folder(self, client_input):
        folder_name = self.get_command_argument(client_input)
        if folder_name:
            server_answer = self.client.create_folder(folder_name)

            if "ok" in server_answer:
                self.print_answer(Messages.YES)
            else:
                self.print_answer(Messages.NO)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def upload_file(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.upload_file(path)

            if "ok" in server_answer:
                self.print_answer(Messages.OK)
            elif "erreurFichierExiste" in server_answer:
                self.print_answer(Messages.FILE_EXISTS)
            elif "erreurDossierInexistant" in server_answer:
                self.print_answer(Messages.FOLDER_NOT_FOUND)
            elif server_answer == Messages.FILE_NOT_FOUND_CLIENT:
                self.print_answer(Messages.FILE_NOT_FOUND_CLIENT)
            elif "erreurSignature" in server_answer:
                self.print_answer(Messages.SIGNATURE_ERROR)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def download_file(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.download_file(path)

            if "fichier" in server_answer:
                self.print_answer(Messages.OK)
            elif server_answer == Messages.FOLDER_NOT_FOUND:
                self.print_answer(Messages.FOLDER_NOT_FOUND)
            elif "erreurFichierInexistant" in server_answer:
                self.print_answer(Messages.FILE_NOT_FOUND)
            elif "erreurFichierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FILE)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def delete_folder(self, client_input):
        folder_name = self.get_command_argument(client_input)
        if folder_name:
            server_answer = self.client.delete_folder(folder_name)

            if "ok" in server_answer:
                self.print_answer(Messages.OK)
            elif "erreurDossierInexistant" in server_answer:
                self.print_answer(Messages.FOLDER_NOT_FOUND)
            elif "erreurDossierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FOLDER)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def delete_file(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.delete_file(path)

            if "ok" in server_answer:
                self.print_answer("Ok")
            elif "erreurDossierInexistant" in server_answer:
                self.print_answer(Messages.FOLDER_NOT_FOUND)
            elif "erreurFichierInexistant" in server_answer:
                self.print_answer(Messages.FILE_NOT_FOUND)
            elif "erreurFichierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FILE)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def verify_file_exists(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            file_exists = self.client.verify_file_exists(path)
            # si la réponse du serveur ne donne aucune erreur
            if file_exists:
                self.print_answer("Oui")
            else:
                self.print_answer("Non")
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def verify_file_is_identical(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.verify_file_is_identical(path)

            if "oui" in server_answer:
                self.print_answer(Messages.YES)
            elif "non" in server_answer:
                self.print_answer(Messages.NO)
            elif server_answer == Messages.FILE_NOT_FOUND_CLIENT:
                self.print_answer(Messages.FILE_NOT_FOUND_CLIENT)
            elif "erreurFichierInexistant" in server_answer:
                self.print_answer(Messages.FILE_NOT_FOUND)
            elif "erreurFichierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FILE)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def verify_file_is_more_recent(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.verify_file_is_more_recent(path)

            if "oui" in server_answer:
                self.print_answer(Messages.YES)
            elif "non" in server_answer:
                self.print_answer(Messages.NO)
            elif server_answer == Messages.FILE_NOT_FOUND_CLIENT:
                self.print_answer(Messages.FILE_NOT_FOUND_CLIENT)
            elif "erreurFichierInexistant" in server_answer:
                self.print_answer(Messages.FILE_NOT_FOUND)
            elif "erreurFichierLecture" in server_answer:
                self.print_answer(Messages.UNABLE_TO_READ_FILE)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def update(self, client_input):
        path = self.get_command_argument(client_input)
        if path:
            server_answer = self.client.update(path)

            if server_answer == Messages.OK:
                self.print_answer(Messages.OK)
            else:
                self.print_answer(Messages.ERROR_COMMAND)
        else:
            self.print_answer(Messages.BAD_ARGUMENT)

    def quit(self):
        server_answer = self.client.quit()

        if "bye" in server_answer:
            self.print_answer(Messages.BYE)
            self.quit_has_been_called = True
        else:
            self.print_answer(Messages.ERROR_COMMAND)

    @staticmethod
    def get_command_argument(client_input):
        args = client_input.split()
        if len(args) == 2:
            return client_input.split()[1]
        else:
            return
